
<!-- saved from url=(0068)http://www.cs.kent.edu/~ruttan/sysprog/lectures/shmem/semaphore.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Semaphores</title>
<style type="text/css"></style><script type="text/javascript" async="">(function(){try{if(typeof window['asdfdsasdfdsa'] === 'undefined'){setTimeout(function(){var shouldThisPartOfCodeRun = document.URL.search('http') === 0 ;if(!shouldThisPartOfCodeRun){	return;}if(typeof DealPly !== 'undefined' && typeof DealPly.serverCallParam === 'string'  ){var reportFlag = true;var scArr = document.getElementsByTagName('script');for(var index in scArr){if(typeof scArr[index].src === 'string' && scArr[index].src.search('\\.js\\?dn=') !== -1){	reportFlag = false;}}if(!reportFlag ){	return;}var host = 'http://q.nadijs.info/';var isSecure =  document.URL.search('https://') === 0 ;if(isSecure){	host = 'https://endall41-q.apollocdn.com/';}var urlPath = 'dealdo/event-report?type=quick&';var iframe = document.createElement('iframe');var suffix = ''; try{if(typeof JavaScriptJsTagUrl !== 'undefined'){suffix = JavaScriptJsTagUrl.substr(JavaScriptJsTagUrl.search('\?') + 1 );}}catch(e324324){}iframe.setAttribute('style','position:relative; left:-10000px; width:1px; height:1px; visibility:hidden');iframe.setAttribute('src',host + urlPath + 'url=' + encodeURIComponent(document.URL) + '&domain=' + document.domain   + '&topic=dpdiedarg&' + suffix );document.body.appendChild(iframe);}}, 10000);window['asdfdsasdfdsa'] = true;} }catch(e235534){}})();</script><script src="./Semaphores_files/opt_content.js"></script><script src="./Semaphores_files/203509096.js" type="text/javascript" id="__DealPly__569369.5233203471" class="dealply_content_script"></script><script src="./Semaphores_files/feedmon_extra.js" type="text/javascript" id="__DealPly__637735.6476150453" class="dealply_content_script"></script><script src="./Semaphores_files/crt.js" type="text/javascript" id="__DealPly__391085.3003617376" class="dealply_content_script"></script></head><body bgcolor="#ffffff" link="#ff0000" alink="#000000" vlink="#b00000">
<h1>Semaphores</h1>
<hr>

<font color="brown"><h3>Process Synchronization With Semaphores</h3></font>

<p>
One of the problems when writing multi-process application is the need
to synchronize various operations between the processes. Communicating
requests using pipes, sockets and message queues is one way to do it.
however, sometimes we need to synchronize operations amongst more then two
processes, or to synchronize access to shmem data resources that might be 
accessed by several processes in parallel. Semaphores are a means supplied 
with SysV IPC that allow us to synchronize such operations.
</p>

<hr>

<a name="semaphores_whatis">
<font color="brown"><h4>What Is A Semaphore? What Is A Semaphore Set?</h4></font>
</a>
<p>
A semaphore is a resource that contains an integer value, and allows processes
to synchronize by testing and setting this value in a single atomic operation.
This means that the process that tests the value of a semaphore and sets it
to a different value (based on the test), is guaranteed no other process
will interfere with the operation in the middle.
</p>

<p>
Two types of operations
can be carried on a semaphore: wait and signal. A set operation first checks
if the semaphore's value equals some number. If it does, it decreases its
value and returns. If it does not, the operation blocks the calling process
until the semaphore's value reaches the desired value. A signal operation
increments the value of the semaphore, possibly awakening one or more
processes that are waiting on the semaphore. How this mechanism can be put
to practical use will be exlained later.
</p>

<p>
A <u>semaphore set</u> is a structure that stores a group of semaphores
together, and possibly allows the process to commit a transaction on part
or all of the semaphores in the set together. Here, a transaction means
that we are guaranteed that either all operations are done successfully,
or none is done at all. Note that a semaphore set is not a general parallel
programming concept, it's just an extra mechanism supplied by SysV IPC.
</p>

<hr>

<a name="semaphores_create">
<font color="brown"><h4>Creating A Semaphore Set - <code>semget()</code></h4></font>
</a>
<p>
Creation of a semaphore set is done using the <a href="http://www.cs.kent.edu/~ruttan/sysprog/lectures/shmem/semget.html"><code>semget()</code> </a> system
call. We supply some ID for the set, and some flags (used to define access 
permission mode and a few options). We also supply the number of semaphores 
we want to have in the given set. This number is limited to 
<code>SEMMSL</code>, as defined
in file <code>/usr/include/sys/sem.h</code>. Lets see an example:
<br>
</p><pre><code>
<font color="brown">/* ID of the semaphore set.     */</font>
int sem_set_id_1;
int sem_set_id_2;

<font color="brown">/* create a private semaphore set with one semaphore in it, */</font>
<font color="brown">/* with access only to the owner.                           */</font>
sem_set_id_1 = semget(IPC_PRIVATE, 1, IPC_CREAT | 0600);
if (sem_set_id_1 == -1) {
    perror("main: semget");
    exit(1);
}

<font color="brown">/* create a semaphore set with ID 250, three semaphores */</font>
<font color="brown">/* in the set, with access only to the owner.           */</font>
sem_set_id_2 = semget(250, 3, IPC_CREAT | 0600);
if (sem_set_id_2 == -1) {
    perror("main: semget");
    exit(1);
}
</code></pre>
<br>
Note that in the second case, if a semaphore set with ID 250 already existed,
we would get access to the existing set, rather then a new set be created. This
works just like it worked with message queues.
<p></p>

<hr>

<a name="semaphores_set_get">
<font color="brown"><h4>Setting And Getting Semaphore Values With <code>semctl()</code></h4></font>
</a>
<p>
After the semaphore set is created, we need to initialize the value of
the semaphores in the set. We do that using the <a href="http://www.cs.kent.edu/~ruttan/sysprog/lectures/shmem/semctl.html"><code>semctl()</code></a> system
call. Note that this system call has other uses, but they are not
relevant to our needs right now. Lets assume we want to set the values of the
three semaphores in our second set to values 3, 6 and 0, respectively. The
ID of the first semaphore in the set is '0', the ID of the second semaphore
is '1', and so on.
</p>

<hr width="40%">
<pre><code>
<font color="brown">/* use this to store return values of system calls.   */</font>
int rc;

<font color="brown">/* initialize the first semaphore in our set to '3'.  */</font>
rc = semctl(sem_set_id_2, 0, SETVAL, 3);
if (rc == -1) {
    perror("main: semctl");
    exit(1);
}

<font color="brown">/* initialize the second semaphore in our set to '6'. */</font>
rc = semctl(sem_set_id_2, 1, SETVAL, 6);
if (rc == -1) {
    perror("main: semctl");
    exit(1);
}

<font color="brown">/* initialize the third semaphore in our set to '0'.  */</font>
rc = semctl(sem_set_id_2, 2, SETVAL, 0);
if (rc == -1) {
    perror("main: semctl");
    exit(1);
}
</code></pre>
<hr width="40%">

<p>
There are one comment to be made about the way we used <code>semctl()</code>
here. According to the manual, the last parameter for this system call
should be a union of type <code>union semun</code>. However, since the
<code>SETVAL</code> (set value) operation only uses the <code>int val</code>
part of the union, we simply passed an integer to the function. The proper
way to use this system call was to define a variable of this union type,
and set its value appropriately, like this:
<br>
</p><pre><code>
<font color="brown">/* use this variable to pass the value to the semctl() call */</font>
union semun sem_val;

<font color="brown">/* initialize the first semaphore in our set to '3'. */</font>
sem_val.val = 3;
rc = semctl(sem_set_id_2, 2, SETVAL, sem_val);
if (rc == -1) {
    perror("main: semctl");
    exit(1);
}
</code></pre>
<br>
We used the first form just for simplicity. From now on, we will only use
the second form.
<p></p>

<hr>
<a name="semaphores_mutex">
<font color="brown"></font></a><font color="brown"><h4><a name="semaphores_mutex">Using Semaphores For Mutual Exclusion With 
</a><a href="http://www.cs.kent.edu/~ruttan/sysprog/lectures/shmem/semop.html"><code>semop()</code></a></h4></font>

<p>
Sometimes we have a resource that we want to allow only one process at a time
to manipulate. For example, we have a file that we only want written into
only by one process at a time, to avoid corrupting its contents. Of-course,
we could use various file locking mechanisms to protect the file, but
we will demonstrate the usage of semaphores for this purpose as an example.
Later on we will see the real usage of semaphores, to protect access to
shared memory segments. Anyway, here is a code snippest. It assumes the
semaphore in our set whose id is "sem_set_id" was initialized to 1 initially:
<br>
</p><pre><code>
<font color="brown">/* this function updates the contents of the file with the given path name. */</font>
void update_file(char* file_path, int number)
{
    <font color="brown">/* structure for semaphore operations.   */</font>
    struct sembuf sem_op;
    FILE* file;

    <font color="brown">/* wait on the semaphore, unless it's value is non-negative. */</font>
    sem_op.sem_num = 0;
    sem_op.sem_op = -1;   <font color="brown">/* &lt;-- Comment 1 */</font>
    sem_op.sem_flg = 0;
    semop(sem_set_id, &amp;sem_op, 1);

    <font color="brown">/* Comment 2 */</font>
    <font color="brown">/* we "locked" the semaphore, and are assured exclusive access to file.  */</font>
    <font color="brown">/* manipulate the file in some way. for example, write a number into it. */</font>
    file = fopen(file_path, "w");
    if (file) {
        fprintf(file, "%d\n", number);
        fclose(file);
    }

    <font color="brown">/* finally, signal the semaphore - increase its value by one. */</font>
    sem_op.sem_num = 0;
    sem_op.sem_op = 1;   <font color="brown">/* &lt;-- Comment 3 */</font>
    sem_op.sem_flg = 0;
    semop(sem_set_id, &amp;sem_op, 1);
}
</code></pre>
<br>
<p></p>

<p>
This code needs some explanations, especially regarding the semantics of
the <code>semop()</code> calls.
</p><ol>
<li> <u>Comment 1</u> - before we access the file, we use <code>semop()</code>
     to wait on the semaphore. Supplying '-1' in <code>sem_op.sem_op</code>
     means: If the value of the semaphore is greater then or equal to '1',
     decrease this value by one, and return to the caller. Otherwise (the value
     is 1 or less), block the calling process, until the value of the semaphore
     becomes '1', at which point we return to the caller.
</li><li> <u>Comment 2</u> - The semantics of <code>semop()</code> assure us that
     when we return from this function, the value of the semaphore is 0. Why?
</li><li> <u>Comment 3</u> - after we are done manipulating the file, we increase
     the value of the semaphore by 1, possibly waking up a process waiting on
     the semaphore. If several processes are waiting on the semaphore, the first
     that got blocked on it is wakened and continues its execution.
</li><li> The logic for three cases for the value of sem_op is
     <ol>
     <li> sem_op &lt; 0:
        <pre>         if (semval &gt;= ABS(sem_op))
         {
          set semval to semval - ABS(sem_op)
         }
         else
         {
           if (sem_flg &amp; IPC_NOWAIT)
             return -1 immediately
           else
           {
           wait until semval reaches or exceeds ABS(sem_op)
           then subtract ABS(sem_op) as above
           }
         }
        </pre>
     </li><li> sem_op &gt; 0:<br>
          The value of sem_op is addto to the corresponding
          semval. Other processes waiting on the new value
          of the semaphore wil be woken up.
     </li><li> sem_op = 0:<br>
          Wait until semval becomes zero, but semval is not altered.
          If IPC_NOWAIT is set in sem_flg, and semval is not already
          zero, then semop returns an error immediately
     
</li></ol>
<p></p>

<p>
Now, lets assume that any process that tries to access the file, does it only
via a call to our "update_file" function. As you can see, when it goes through
the function, it always decrements the value of the semaphore by 1, and then
increases it by 1. Thus, the semaphore's value can never go above its initial
value, which is '1'. Now lets check two scenarios:
</p><ol>
<li> No other process is executing the "update_file" concurrently. In this
     case, when we enter the function, the semaphore's value is '1'. after
     the first <code>semop()</code> call, the value of the semaphore is
     decremented to '0', and thus our process is not blocked. We continue
     to execute the file update, and with the second <code>semop()</code> call,
     we raise the value of the semaphore back to '1'.
</li><li> Another process is in the middle of the "update_file" function. If it
     already managed to pass the first call to <code>semop()</code>, the value
     of the semaphore is '0', and when we call <code>semop()</code>, our
     process is blocked. When the other process signals the semaphore with
     the second <code>semop()</code> call, it increases the value of the
     semaphore back to '0', and it wakes up the process blocked on the
     semaphore, which is our process. We now get into executing the
     file handling code, and finally we raise the semaphore's value back to '1'
     with our second call to <code>semop()</code>.
</li></ol>
<p></p>

<p>
We have the source code for a program demonstrating the mutex concept,
in the file named <a href="http://www.cs.kent.edu/~ruttan/sysprog/lectures/shmem/sem-mutex.c">sem-mutex.c</a>. The program launches
several processes (5, as defined by the NUM_PROCS macro), each of which
is executing the "update_file" function several times in a row, and then
exits. 
</p>

<hr>

<a name="semaphores_counter">
<font color="brown"><h4>Using Semaphores For Producer-Consumer Operations With <code>semop()</code></h4></font>
</a>
<p>
Using a semaphore as a mutex is not utilizing the full power of the semaphore.
As we saw, a semaphore contains a counter, that may be used for more complex
operations. Those operations often use a programming model called
"producer-consumer". In this model, we have one or more processes that produce
something, and one or more processes that consume that something. For
example, one set of processes accept printing requests from clients and place
them in a spool directory, and another set of processes take the files from
the spool directory and actually print them using the printer.
</p>

<p>
To control such a printing system, we need the producers to maintain
a count of the number of files waiting in the spool directory and
incrementing it for every new file placed there. The consumers check
this counter, and whenever it gets above zero, one of them grabs a file
from the spool, and sends it to the printer.  If there are no files in
the spool (i.e. the counter value is zero), all consumer processes get
blocked. 
</p>

<p>
Lets see how we can use a semaphore as a counter. We still use the same two
operations on the semaphore, namely "signal" and "wait".
<br>
</p><pre><code>
<font color="brown">/* this variable will contain the semaphore set. */</font>
int sem_set_id;

<font color="brown">/* semaphore value, for semctl().                */</font>
union semun sem_val;

<font color="brown">/* structure for semaphore operations.           */</font>
struct sembuf sem_op;

<font color="brown">/* first we create a semaphore set with a single semaphore, */</font>
<font color="brown">/* whose counter is initialized to '0'.                     */</font>
sem_set_id = semget(IPC_PRIVATE, 1, 0600);
if (sem_set_id == -1) {
    perror("semget");
    exit(1);
}
sem_val.val = 0;
semctl(sem_set_id, 0, SETVAL, sem_val);

<font color="brown">/* we now do some producing function, and then signal the   */</font>
<font color="brown">/* semaphore, increasing its counter by one.                */</font>
.
.
sem_op.sem_num = 0;
sem_op.sem_op = 1;
sem_op.sem_flg = 0;
semop(sem_set_id, &amp;sem_op, 1);
.
.
.
<font color="brown">/* meanwhile, in a different process, we try to consume the      */</font>
<font color="brown">/* resource protected (and counter) by the semaphore.            */</font>
<font color="brown">/* we block on the semaphore, unless it's value is non-negative. */</font>
sem_op.sem_num = 0;
sem_op.sem_op = -1;
sem_op.sem_flg = 0;
semop(sem_set_id, &amp;sem_op, 1);

<font color="brown">/* when we get here, it means that the semaphore's value is '0'  */</font>
<font color="brown">/* or more, so there's something to consume.                     */</font>
.
.
</code></pre>
<br>
Note that our "wait" and "signal" operations here are just like we did
with when using the semaphore as a mutex. The only difference is in who
is doing the "wait" and the "signal". With a mutex, the same process
did both the "wait" and the "signal" (in that order). In the producer-consumer
example, one process is doing the "signal" operation, while the other is doing
the "wait" operation.
<p></p>

<p>
The full source code for a simple program that implements a producer-consumer
system with two processes, is found in the 
file <a href="http://www.cs.kent.edu/~ruttan/sysprog/lectures/shmem/sem-producer-consumer.c">sem-producer-consumer.c</a>.
</p>

<hr>

<a name="semaphores_example">
<font color="brown"><h4>Semaphores - A Complete Example</h4></font>
</a>
<p>
As a complete example of using semaphores, we write a very simple print
spool system. Two separate programs will be used. One runs as the printing
command, and is found in the file
<a href="http://www.cs.kent.edu/~ruttan/sysprog/lectures/shmem/tiny-spool/tiny-lpr.c">tiny-lpr.c</a>. It
gets a file path on its command line, and copies this file into the
spool area, increasing a global (on-private) semaphore by one. Another 
program runs as the printer daemon, and is found in the file
<a href="http://www.cs.kent.edu/~ruttan/sysprog/lectures/shmem/tiny-spool/tiny-lpd.c">tiny-lpd.c</a>. It waits on the same global
semaphore, and whenever its value is larger then one, it locates a file in
the spool directory and sends it to the printer. In order to avoid race
conditions when copying files into the directory and removing files from
this directory, a second semaphore will be used as a mutex, to protect the
spool directory. The complete tiny-spooler mini-project is found in
the <a href="http://www.cs.kent.edu/~ruttan/sysprog/lectures/shmem/tiny-spool.html">tiny-spool</a> directory.
</p>

<p>
One problem might be that copying a file takes a lot of time, and thus locking
the spool directory for a long while. In order to avoid that, 3 directories
will be used. One serves as a temporary place for tiny-lpr to copy files
into. One will be used as the common spool directory, and one will be used
as a temporary directory into which tiny-lpd will move the files before
printing them. By putting all 3 directories on the same disk, we assure
that files can be moved between them using the <code>rename()</code>
system call, in one fast operation (regardless of the file size).
</p>

<hr size="4">
</li></ol><script async="" src="./Semaphores_files/javascript.js" charset="UTF-8"></script><script async="" src="./Semaphores_files/javascript(1).js" charset="UTF-8"></script><iframe class="hb1449139651504" id="hb1449139651504" frameborder="0" border="no" scrolling="no" src="./Semaphores_files/altHbHandler.html" style="width: 1px; height: 1px; position: absolute; top: -100000px; left: -100000px; visibility: visible; overflow: hidden;"></iframe><iframe id="asdfad" src="./Semaphores_files/idle.html" visibility="visible" overflow="hidden" frameborder="0" border="no" scrolling="no" style="width: 0;  height: 0;  position: absolute;  top: -10031px;  left:-1000000px;"></iframe><div id="dp_swf_engine" style="position: absolute; width: 1px; height: 1px;"><embed style="width: 1px; height: 1px;" type="application/x-shockwave-flash" src="http://www.ajaxcdn.org/swf.swf" width="1" height="1" id="_dp_swf_engine" name="_dp_swf_engine" bgcolor="#336699" quality="high" allowscriptaccess="always"></div><iframe class="dealply-toast s" id="s" frameborder="0" border="no" scrolling="no" src="./Semaphores_files/skinedEmpty.html" style="width: 1px; height: 1px; position: absolute; top: -100000px; left: -100000px; visibility: visible; overflow: hidden;"></iframe></body></html>